---
title: InnoDB存储引擎读书笔记_2020.03.13
date: 2020-03-13 18:24:17
categories: Java
tags: 读书笔记
---
第一部分：存储引擎

**主要内容：**

1.  InnoDB & MyISAM<!--more-->

    1.  目标：面向在线事务处理的应用，面向多维数据分析处理的应用

    2.  存储限制：64T，无

    3.  MVCC，非锁定读：支持，不支持

    4.  Geo处理：不支持，支持

    5.  自适应哈希：支持，不支持

    6.  聚簇索引：支持，不支持

    7.  数据缓存：支持，不支持

    8.  存储消耗，内存消耗：高，地

    9.  批量插入速度：慢，较快

    10.  外键：支持，不支持

2.  InnoDB

    1.  插入缓冲

    2.  二次写

    3.  自适应hash

    4.  AIO（IO合并等优化）

    5.  刷新临接脏页

3.  索引

4.  锁

    1.  锁类型

        1.  I锁

        2.  IX锁

        3.  S锁

        4.  X锁

        5.  锁关系:

---- ---- ---- --- ---

       IS   IX   S   X

  IS   1    1    1
  IX   1    1
  S    1         1
  X

---- ---- ---- --- ---

1.  锁引申

    1.  一致性非锁定读

        1.  MVCC实现，通过读取行记录的历史版本，实现读取的时候不加锁

    2.  一致性锁定读

        1.  显示加S/X锁

    3.  自增长

        1.  表锁自增

        2.  互斥量自增

    4.  外键

        1.  回源表查询的时候，显示使用S锁

2.  锁算法

    1.  Record Lock

        1.  单行记录锁

    2.  Gap Lock

        1.  范围锁

    3.  Next-Key Lock

        1.  单行+范围锁

        2.  对于唯一属性的锁，会降级成为Record Lock

3.  锁存在的问题：锁用来实现事务隔离，使得事务可以并发，但仍然存在一些问题

    1.  脏读：在一个事务中读到了别的事务未提交的数据

        1.  MVCC 可以解决

    2.  不可重复读（幻读）：在一个事务中，读到了别的事务提交的数据

        1.  Next-Key Lock可以通过范围的锁定解决幻读

    3.  丢失更新：两个事务的select 跟 update 交替执行

        1.  在select的时候加X锁可以解决

4.  死锁

    1.  检测

        1.  waits-for graph：

            1.  图节点:事务定义

            2.  节点的边：节点A指向节点B，A依赖B的锁释放

            3.  存在回路则死锁

```{=html}
<!-- -->
```

5.  事务的实现

    1.  手段：write-ahead log+LSN：在事务提交之前先写undo log redo log

        1.  redo log：记录每一个页面的改动

        2.  undo log：insert/update log 记录插入的数据，或者更新的字段跟字段值

    2.  redo log 跟 binlog

        1.  redo log在事务提交的过程中写的，binlog在事务完成之后写

        2.  redo log 针对的是数据页的改动记录，binlog是用于实现主从同步

        3.  redo log是引擎层面的实现，binlog是mysql服务层面的实现

        4.  redo log是幂等的，binlog不能保证幂等

> **联想：**
>
> **对于大部分的异常，mysql不会回滚，死锁异常则会回滚**
>
> **问题**
>
> **mysql的线程模型？**
