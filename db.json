{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/avatar.jpeg","path":"img/avatar.jpeg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1584505185779},{"_id":"themes/yilia/_config.yml","hash":"ffb484f5fb634fe0a6f3c0601a371addcec7e88c","modified":1584505670810},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1584505185800},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1584505185834},{"_id":"source/_posts/HelloWorld.md","hash":"3cded9506ae41c6d31aa9f94392cd7801677bc5b","modified":1584505142294},{"_id":"source/_posts/Mockito单元测试常见套路.md","hash":"ec22e5a4b2aafb5db8f6c200070c66834d347540","modified":1584505076310},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1584505185781},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1584505185782},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1584505185783},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1584505185783},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1584505185781},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1584505185783},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1584505185782},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1584505185784},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1584505185784},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1584505185784},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1584505185785},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1584505185799},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1584505185784},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1584505185785},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1584505185801},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1584505185804},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1584505185834},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1584505185833},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1584505185795},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1584505185805},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1584505185800},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1584505185796},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1584505185792},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1584505185792},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1584505185798},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1584505185795},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1584505185793},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1584505185797},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1584505185797},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1584505185792},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1584505185795},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1584505185794},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1584505185786},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1584505185786},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1584505185798},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1584505185793},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1584505185799},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1584505185808},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1584505185808},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1584505185807},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1584505185806},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1584505185806},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1584505185807},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1584505185803},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1584505185802},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1584505185802},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1584505185821},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1584505185822},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1584505185823},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1584505185823},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1584505185817},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1584505185809},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1584505185816},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1584505185824},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1584505185821},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1584505185810},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1584505185827},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1584505185817},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1584505185815},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1584505185810},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1584505185820},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1584505185820},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1584505185826},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1584505185822},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1584505185813},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1584505185827},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1584505185827},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1584505185823},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1584505185821},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1584505185826},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1584505185810},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1584505185819},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1584505185817},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1584505185830},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1584505185828},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1584505185829},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1584505185832},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1584505185833},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1584505185831},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1584505185828},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1584505185831},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1584505185832},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1584505185832},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1584505185829},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1584505185830},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1584505185794},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1584505185788},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1584505185787},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1584505185790},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1584505185790},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1584505185791},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1584505185789},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1584505185791},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1584505185789},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1584505185788},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1584505185789},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1584505185812},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1584505185813},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1584505185811},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1584505185812},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1584505185811},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1584505185825},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1584505185825},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1584505185818},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1584505185819},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1584505185818},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1584505185825},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1584505185824},{"_id":"public/content.json","hash":"98c88a2d34dcd1cf620adbeb46ec123ffd9ecb07","modified":1584505440574},{"_id":"public/2017/10/04/HelloWorld/index.html","hash":"9039ba8140bbad6e454d57a17705bd4fec980fc8","modified":1584505718597},{"_id":"public/archives/index.html","hash":"f6f8bf5fa4723e2ea2312bbd97dc4afdba279ca6","modified":1584505718598},{"_id":"public/archives/2017/index.html","hash":"077fba98dd68a7e3080248e2b0ffd07e3a3daf34","modified":1584505718599},{"_id":"public/archives/2017/10/index.html","hash":"9b396611124faf3c46b2cc1265450c75ccee9f58","modified":1584505718599},{"_id":"public/index.html","hash":"56b0fe2a1557d8e8585e9c200ad740c8a1940c76","modified":1584505718598},{"_id":"public/tags/闲言碎语/index.html","hash":"f8048ccdb8c0732230ef82dea51cf00b4bef2e83","modified":1584505718598},{"_id":"public/2017/10/07/Mockito单元测试常见套路/index.html","hash":"8fe9732167f738ac554b2c7f1a82ae27acfc1ce8","modified":1584505718597},{"_id":"public/tags/测试/index.html","hash":"0b58fb429f43106db18fa745d7926d3b23d5d825","modified":1584505718598},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1584505440660},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1584505440660},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1584505440660},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1584505440661},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1584505440661},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1584505440661},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1584505440661},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1584505440661},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1584505440667},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1584505440672},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1584505440672},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1584505440673},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1584505440673},{"_id":"themes/yilia/source/img/avatar.jpeg","hash":"e79d8c479bbccf9f49f0c7746d5b2b3d03aac544","modified":1584505641479},{"_id":"public/img/avatar.jpeg","hash":"e79d8c479bbccf9f49f0c7746d5b2b3d03aac544","modified":1584505718601}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"国庆随笔","date":"2017-10-04T15:14:07.000Z","comments":1,"_content":"\n今年国庆+中秋，终于回家了，以前在学校的时候，国庆七天假一般都待在学校，主要是因为那会儿还有寒暑假，所以国庆的七天并没有多大的吸引力。但现在不一样了，现在就只有一些零零散散的假期了。\n  \n转眼出来工作半年了，也毕业了三个月了，实习三个月，试用三个月，我也经常反思一些东西，但很少写下来，今天接着这个blog的东风，随便写写。\n  \n\n#### 关于blog\n  \n其实很早之前就想玩玩这个git pages，但总是浅尝辄止，主要是Vbox上的ubuntu确实有点恶心(没有装那个增强功能，装上了就挺好的)，而我又不想在工作本上搭这些环境，昨天花了一个下午用hexo把git pages搭了起来，感觉搭这个并不难，难的是找到一个酷一点的模板毕竟【看脸】【尴尬】。\n\n#### 生活琐事\n  \n今年国庆老大也回家了，好像大学以来第一次中秋大家都在吧，不过老大就放假了4天，而且家里还在搞装修，整的有点乱，今天早上吃完饭老大就回福州了，临走前我们打了个赌，今年过年回家时，没有腹肌的要给有腹肌的2000块钱红包【哈哈】。记得之前给老大推荐过keep，然后今年回来的时候老大已经减了15斤了，看来这2000块钱还有是有点压力的【嘿嘿】\n  \n今年回家也少不了走走亲戚，真的和以前不一样了，现在的问题都是，有女朋友没，工资怎么样，待遇怎么样，当然偶尔也有几句累不累。\n\n#### 朋友圈\n  \n这个我觉得有必要单独拿出来讲了，我只想说大兄弟们你们太会玩了，上山下海，飞天遁地,横跨沙漠，深海潜水，然后各种晒照，真的是。。。【好羡慕啊】【哈哈】，话说国庆已经到了第5天了，第一天我是在动车上过的，然后第一天躺尸，第二天躺尸，第三，四，五天还是躺尸【哎呀我去，过分了】，不过躺尸不是睡觉啊，就是宅在家里把玩电脑【把玩这个词不错】，其实我也不是不想出门，只是因为‘就不想就出门啊’【尴尬】【哈哈】。\n  \n#### 程序猿\n  \n一直在网上看到一些段子，程序猿996各种加班各种猝死，产品改需求，各种要疯掉崩溃。老实说在有赞的这段日子里并没有体会到这些东西，早9点晚9点也还行吧，当然可能是我还单身的原因（难怪有道面试题叫你有女朋友吗），还有产品改需求，这个其实不好说，但是如果你能确定产品不是个傻子，而且他的修改是经过思考，重点是如果你也觉得这样改是对的，那就改吧。。。。\n  \n#### 忘了说的正能量【嘿嘿】\n  \n其实要不是那天在泥土里打过滚，受了伤还依然不想放弃，我都想不到这个--竞技精神\n  \n我觉得竞技就是想赢敢赢不服输不怕输，我觉得我算是一个有竞技精神的人，只不过在这之前一直没把这个精神划到自己身上，记得大学之前打字还要在键盘上找，五音也不全，然而只要有计算机的比赛我就去敢水一波，连院里的才艺大赛都敢上去唱歌，就算从头到尾没跟上一次伴奏我还是把他给唱完了，我觉得我并不在乎别人的眼光，但我在意别人在背后怎么说我（突然想到的，不知道你们理解了没，感觉有点说不通，算了，先这样）【尴尬】，所以当我意识到这个竞技精神的存在时，我就决定以后要带着这种精神上路。当你还没站在最高峰的时候，追逐胜利其实是一个自我提升的过程，而且也会是一种双赢的良好循环。\n\n### 试着打赏一下，说不定会有惊喜哦【嘿嘿】\n","source":"_posts/HelloWorld.md","raw":"---\ntitle: 国庆随笔\ntags: 闲言碎语\ndate: 2017-10-04 23:14:07\ncomments: true\n---\n\n今年国庆+中秋，终于回家了，以前在学校的时候，国庆七天假一般都待在学校，主要是因为那会儿还有寒暑假，所以国庆的七天并没有多大的吸引力。但现在不一样了，现在就只有一些零零散散的假期了。\n  \n转眼出来工作半年了，也毕业了三个月了，实习三个月，试用三个月，我也经常反思一些东西，但很少写下来，今天接着这个blog的东风，随便写写。\n  \n\n#### 关于blog\n  \n其实很早之前就想玩玩这个git pages，但总是浅尝辄止，主要是Vbox上的ubuntu确实有点恶心(没有装那个增强功能，装上了就挺好的)，而我又不想在工作本上搭这些环境，昨天花了一个下午用hexo把git pages搭了起来，感觉搭这个并不难，难的是找到一个酷一点的模板毕竟【看脸】【尴尬】。\n\n#### 生活琐事\n  \n今年国庆老大也回家了，好像大学以来第一次中秋大家都在吧，不过老大就放假了4天，而且家里还在搞装修，整的有点乱，今天早上吃完饭老大就回福州了，临走前我们打了个赌，今年过年回家时，没有腹肌的要给有腹肌的2000块钱红包【哈哈】。记得之前给老大推荐过keep，然后今年回来的时候老大已经减了15斤了，看来这2000块钱还有是有点压力的【嘿嘿】\n  \n今年回家也少不了走走亲戚，真的和以前不一样了，现在的问题都是，有女朋友没，工资怎么样，待遇怎么样，当然偶尔也有几句累不累。\n\n#### 朋友圈\n  \n这个我觉得有必要单独拿出来讲了，我只想说大兄弟们你们太会玩了，上山下海，飞天遁地,横跨沙漠，深海潜水，然后各种晒照，真的是。。。【好羡慕啊】【哈哈】，话说国庆已经到了第5天了，第一天我是在动车上过的，然后第一天躺尸，第二天躺尸，第三，四，五天还是躺尸【哎呀我去，过分了】，不过躺尸不是睡觉啊，就是宅在家里把玩电脑【把玩这个词不错】，其实我也不是不想出门，只是因为‘就不想就出门啊’【尴尬】【哈哈】。\n  \n#### 程序猿\n  \n一直在网上看到一些段子，程序猿996各种加班各种猝死，产品改需求，各种要疯掉崩溃。老实说在有赞的这段日子里并没有体会到这些东西，早9点晚9点也还行吧，当然可能是我还单身的原因（难怪有道面试题叫你有女朋友吗），还有产品改需求，这个其实不好说，但是如果你能确定产品不是个傻子，而且他的修改是经过思考，重点是如果你也觉得这样改是对的，那就改吧。。。。\n  \n#### 忘了说的正能量【嘿嘿】\n  \n其实要不是那天在泥土里打过滚，受了伤还依然不想放弃，我都想不到这个--竞技精神\n  \n我觉得竞技就是想赢敢赢不服输不怕输，我觉得我算是一个有竞技精神的人，只不过在这之前一直没把这个精神划到自己身上，记得大学之前打字还要在键盘上找，五音也不全，然而只要有计算机的比赛我就去敢水一波，连院里的才艺大赛都敢上去唱歌，就算从头到尾没跟上一次伴奏我还是把他给唱完了，我觉得我并不在乎别人的眼光，但我在意别人在背后怎么说我（突然想到的，不知道你们理解了没，感觉有点说不通，算了，先这样）【尴尬】，所以当我意识到这个竞技精神的存在时，我就决定以后要带着这种精神上路。当你还没站在最高峰的时候，追逐胜利其实是一个自我提升的过程，而且也会是一种双赢的良好循环。\n\n### 试着打赏一下，说不定会有惊喜哦【嘿嘿】\n","slug":"HelloWorld","published":1,"updated":"2020-03-18T04:19:02.294Z","layout":"post","photos":[],"link":"","_id":"ck7wtmmi20000l54k3xmxp61l","content":"<p>今年国庆+中秋，终于回家了，以前在学校的时候，国庆七天假一般都待在学校，主要是因为那会儿还有寒暑假，所以国庆的七天并没有多大的吸引力。但现在不一样了，现在就只有一些零零散散的假期了。</p>\n<p>转眼出来工作半年了，也毕业了三个月了，实习三个月，试用三个月，我也经常反思一些东西，但很少写下来，今天接着这个blog的东风，随便写写。</p>\n<h4 id=\"关于blog\"><a href=\"#关于blog\" class=\"headerlink\" title=\"关于blog\"></a>关于blog</h4><p>其实很早之前就想玩玩这个git pages，但总是浅尝辄止，主要是Vbox上的ubuntu确实有点恶心(没有装那个增强功能，装上了就挺好的)，而我又不想在工作本上搭这些环境，昨天花了一个下午用hexo把git pages搭了起来，感觉搭这个并不难，难的是找到一个酷一点的模板毕竟【看脸】【尴尬】。</p>\n<h4 id=\"生活琐事\"><a href=\"#生活琐事\" class=\"headerlink\" title=\"生活琐事\"></a>生活琐事</h4><p>今年国庆老大也回家了，好像大学以来第一次中秋大家都在吧，不过老大就放假了4天，而且家里还在搞装修，整的有点乱，今天早上吃完饭老大就回福州了，临走前我们打了个赌，今年过年回家时，没有腹肌的要给有腹肌的2000块钱红包【哈哈】。记得之前给老大推荐过keep，然后今年回来的时候老大已经减了15斤了，看来这2000块钱还有是有点压力的【嘿嘿】</p>\n<p>今年回家也少不了走走亲戚，真的和以前不一样了，现在的问题都是，有女朋友没，工资怎么样，待遇怎么样，当然偶尔也有几句累不累。</p>\n<h4 id=\"朋友圈\"><a href=\"#朋友圈\" class=\"headerlink\" title=\"朋友圈\"></a>朋友圈</h4><p>这个我觉得有必要单独拿出来讲了，我只想说大兄弟们你们太会玩了，上山下海，飞天遁地,横跨沙漠，深海潜水，然后各种晒照，真的是。。。【好羡慕啊】【哈哈】，话说国庆已经到了第5天了，第一天我是在动车上过的，然后第一天躺尸，第二天躺尸，第三，四，五天还是躺尸【哎呀我去，过分了】，不过躺尸不是睡觉啊，就是宅在家里把玩电脑【把玩这个词不错】，其实我也不是不想出门，只是因为‘就不想就出门啊’【尴尬】【哈哈】。</p>\n<h4 id=\"程序猿\"><a href=\"#程序猿\" class=\"headerlink\" title=\"程序猿\"></a>程序猿</h4><p>一直在网上看到一些段子，程序猿996各种加班各种猝死，产品改需求，各种要疯掉崩溃。老实说在有赞的这段日子里并没有体会到这些东西，早9点晚9点也还行吧，当然可能是我还单身的原因（难怪有道面试题叫你有女朋友吗），还有产品改需求，这个其实不好说，但是如果你能确定产品不是个傻子，而且他的修改是经过思考，重点是如果你也觉得这样改是对的，那就改吧。。。。</p>\n<h4 id=\"忘了说的正能量【嘿嘿】\"><a href=\"#忘了说的正能量【嘿嘿】\" class=\"headerlink\" title=\"忘了说的正能量【嘿嘿】\"></a>忘了说的正能量【嘿嘿】</h4><p>其实要不是那天在泥土里打过滚，受了伤还依然不想放弃，我都想不到这个–竞技精神</p>\n<p>我觉得竞技就是想赢敢赢不服输不怕输，我觉得我算是一个有竞技精神的人，只不过在这之前一直没把这个精神划到自己身上，记得大学之前打字还要在键盘上找，五音也不全，然而只要有计算机的比赛我就去敢水一波，连院里的才艺大赛都敢上去唱歌，就算从头到尾没跟上一次伴奏我还是把他给唱完了，我觉得我并不在乎别人的眼光，但我在意别人在背后怎么说我（突然想到的，不知道你们理解了没，感觉有点说不通，算了，先这样）【尴尬】，所以当我意识到这个竞技精神的存在时，我就决定以后要带着这种精神上路。当你还没站在最高峰的时候，追逐胜利其实是一个自我提升的过程，而且也会是一种双赢的良好循环。</p>\n<h3 id=\"试着打赏一下，说不定会有惊喜哦【嘿嘿】\"><a href=\"#试着打赏一下，说不定会有惊喜哦【嘿嘿】\" class=\"headerlink\" title=\"试着打赏一下，说不定会有惊喜哦【嘿嘿】\"></a>试着打赏一下，说不定会有惊喜哦【嘿嘿】</h3>","site":{"data":{}},"excerpt":"","more":"<p>今年国庆+中秋，终于回家了，以前在学校的时候，国庆七天假一般都待在学校，主要是因为那会儿还有寒暑假，所以国庆的七天并没有多大的吸引力。但现在不一样了，现在就只有一些零零散散的假期了。</p>\n<p>转眼出来工作半年了，也毕业了三个月了，实习三个月，试用三个月，我也经常反思一些东西，但很少写下来，今天接着这个blog的东风，随便写写。</p>\n<h4 id=\"关于blog\"><a href=\"#关于blog\" class=\"headerlink\" title=\"关于blog\"></a>关于blog</h4><p>其实很早之前就想玩玩这个git pages，但总是浅尝辄止，主要是Vbox上的ubuntu确实有点恶心(没有装那个增强功能，装上了就挺好的)，而我又不想在工作本上搭这些环境，昨天花了一个下午用hexo把git pages搭了起来，感觉搭这个并不难，难的是找到一个酷一点的模板毕竟【看脸】【尴尬】。</p>\n<h4 id=\"生活琐事\"><a href=\"#生活琐事\" class=\"headerlink\" title=\"生活琐事\"></a>生活琐事</h4><p>今年国庆老大也回家了，好像大学以来第一次中秋大家都在吧，不过老大就放假了4天，而且家里还在搞装修，整的有点乱，今天早上吃完饭老大就回福州了，临走前我们打了个赌，今年过年回家时，没有腹肌的要给有腹肌的2000块钱红包【哈哈】。记得之前给老大推荐过keep，然后今年回来的时候老大已经减了15斤了，看来这2000块钱还有是有点压力的【嘿嘿】</p>\n<p>今年回家也少不了走走亲戚，真的和以前不一样了，现在的问题都是，有女朋友没，工资怎么样，待遇怎么样，当然偶尔也有几句累不累。</p>\n<h4 id=\"朋友圈\"><a href=\"#朋友圈\" class=\"headerlink\" title=\"朋友圈\"></a>朋友圈</h4><p>这个我觉得有必要单独拿出来讲了，我只想说大兄弟们你们太会玩了，上山下海，飞天遁地,横跨沙漠，深海潜水，然后各种晒照，真的是。。。【好羡慕啊】【哈哈】，话说国庆已经到了第5天了，第一天我是在动车上过的，然后第一天躺尸，第二天躺尸，第三，四，五天还是躺尸【哎呀我去，过分了】，不过躺尸不是睡觉啊，就是宅在家里把玩电脑【把玩这个词不错】，其实我也不是不想出门，只是因为‘就不想就出门啊’【尴尬】【哈哈】。</p>\n<h4 id=\"程序猿\"><a href=\"#程序猿\" class=\"headerlink\" title=\"程序猿\"></a>程序猿</h4><p>一直在网上看到一些段子，程序猿996各种加班各种猝死，产品改需求，各种要疯掉崩溃。老实说在有赞的这段日子里并没有体会到这些东西，早9点晚9点也还行吧，当然可能是我还单身的原因（难怪有道面试题叫你有女朋友吗），还有产品改需求，这个其实不好说，但是如果你能确定产品不是个傻子，而且他的修改是经过思考，重点是如果你也觉得这样改是对的，那就改吧。。。。</p>\n<h4 id=\"忘了说的正能量【嘿嘿】\"><a href=\"#忘了说的正能量【嘿嘿】\" class=\"headerlink\" title=\"忘了说的正能量【嘿嘿】\"></a>忘了说的正能量【嘿嘿】</h4><p>其实要不是那天在泥土里打过滚，受了伤还依然不想放弃，我都想不到这个–竞技精神</p>\n<p>我觉得竞技就是想赢敢赢不服输不怕输，我觉得我算是一个有竞技精神的人，只不过在这之前一直没把这个精神划到自己身上，记得大学之前打字还要在键盘上找，五音也不全，然而只要有计算机的比赛我就去敢水一波，连院里的才艺大赛都敢上去唱歌，就算从头到尾没跟上一次伴奏我还是把他给唱完了，我觉得我并不在乎别人的眼光，但我在意别人在背后怎么说我（突然想到的，不知道你们理解了没，感觉有点说不通，算了，先这样）【尴尬】，所以当我意识到这个竞技精神的存在时，我就决定以后要带着这种精神上路。当你还没站在最高峰的时候，追逐胜利其实是一个自我提升的过程，而且也会是一种双赢的良好循环。</p>\n<h3 id=\"试着打赏一下，说不定会有惊喜哦【嘿嘿】\"><a href=\"#试着打赏一下，说不定会有惊喜哦【嘿嘿】\" class=\"headerlink\" title=\"试着打赏一下，说不定会有惊喜哦【嘿嘿】\"></a>试着打赏一下，说不定会有惊喜哦【嘿嘿】</h3>"},{"title":"Mockito单元测试","date":"2017-10-07T05:14:07.000Z","comments":1,"_content":"\n## Mokcito单元测试 \n> reference : [mockito doc](http://static.javadoc.io/org.mockito/mockito-core/2.10.0/org/mockito/Mockito.html)\n\n### 单元测试why？  \n- 发现问题的成本最低\n- 调教你的编程习惯\n- 保证代码质量\n### 优点\n- 语法简洁，使用简单，易上手\n- 比较有测试的思维（无法随意Mock）\n### 限制\n- 不能mock静态方法\n- 不能mock构造方法\n- 不能mock equals()，hashCode()\n- 不能mock final类 ， final方法\n- 不能mock私有方法，可以把私有，变成protected\n，若你需要mock私有，可能是你的程序还不够OO (Object Oriented)\n### 常规用法\n#### 大体蓝图  \n当你需要桩（取代某个依赖）的时候，你可以用两种方式来模拟桩，spy & mock\n- spy\n```\nMockedObject object = new MockedObject();  \nMockedObject spiedObject = Mockito.spy(object);\n```\n- mock  \n```\nMockedObject mockedObject = Mockito.mock(MockedObject.class);\n```\n- 两者的区别：    \n\n  当你使用spy来获取到一个桩的时候，你在执行某个方法的时候，spy的对象都会==真正的去执行方法内的代码==。  \n  \n  而当桩是通过mock获取到的话，mock的对象的所有属性都为空，所有方法的返回值都是返回类型的默认值（如对象类型的默认值是null），==方法里的代码不会执行==。 \n  \n  其实这点区别是可以从代码层面上看出来的，spy的时候先拿到了一个对象，然后对对象进行spy，而mock的时候使用的则是字节码。  \n- 两者之间的效果也可以互相转化  \n    spy类型的可以通过 ``` doReturn() ``` ，使得代码不被执行，mock类型可以通过 ``` doRealCallMethod() ``` ,使得代码被执行，所以spy和mock的界限其实并不清晰\n- 代码示例  \n  被mock和spy的类 \n\n```\nclass TestMock{\n\n    public void t1 (String ss) {\n        System.out.println(\"hh\"+ss);\n    }\n\n    public String t2 (String ss) {\n        return \"hh\"+ss;\n    }\n\n    public Boolean t3() {\n        return true;\n    }\n\n    public String t4(MockParam mockParam) {\n\n        return mockParam.name;\n    }\n\n    public String t5(MockParam mockParam , String s) {\n        return s;\n    }\n}\n```\n\n  参数类（在上面的类中的某些方法的参数）   \n\n```\nclass MockParam{\n\n    String name;\n\n    int age;\n\n    public MockParam(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        obj = (MockParam)obj;\n        if(this == obj || this.name.equals(((MockParam) obj).name)) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n  mock样例  \n  所有方法的返回都是方法的默认类型，方法内的代码不会被执行\n\n```\npublic void test2() {\n\n    TestMock mock = mock(TestMock.class);\n\n    mock.t1(\"a\");\n\n    System.out.println(mock.t2(\"b\"));\n\n    System.out.println(mock.t3());\n\n    when(mock.t2(\"c\")).thenReturn(\"666\");\n\n    when(mock.t2(\"c\")).thenReturn(\"777\");\n\n    System.out.println(mock.t2(\"c\"));\n}\n\n```\n  \n  spy样例  \n  所有方法的代码都会被执行，并正常返回  \n\n```\npublic void test3() {\n\n    TestMock mock1 = new TestMock();\n\n    TestMock spyTest = spy(mock1);\n\n    spyTest.t1(\"c\");\n\n    System.out.println(spyTest.t2(\"d\"));\n\n    System.out.println(spyTest.t3());\n\n}\n```\n  \n#### 参数匹配 \n- 通常情况下，参数匹配使用的equals方法  \n\n```\n @Test\npublic void test4() {\n\n    TestMock mock = mock(TestMock.class);\n\n    when(mock.t2(\"c\")).thenReturn(\"777\");\n\n    System.out.println(mock.t2(\"d\"));//d,c equals = false\n}\n\n@Test\npublic void test5() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"555\");\n\n    when(mock.t4(mockParam)).thenReturn(\"555\");\n\n    System.out.println(mock.t4(mockParam));//equals true\n\n    System.out.println(mock.t4(new MockParam(\"555\")));//equals false 可以重写equals方法，使之为ture\n\n}\n```\n\n- 内置参数匹配(常用)  \n\n```\n@Test\npublic void test6() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"555\");\n\n    when(mock.t4(any())).thenReturn(\"555\");\n\n    System.out.println(mock.t4(mockParam));//true\n\n    System.out.println(mock.t4(new MockParam(\"555\")));//true\n\n    when(mock.t2(anyString())).thenReturn(\"dddd\");\n\n    System.out.println(mock.t2(\"aaa\"));//return dddd\n\n    System.out.println(mock.t2(\"bbb\"));//return dddd\n}\n```\n\n- 注意\n⚠ :如果有一个参数使用了参数匹配器，那所有参数都得使用参数匹配器\n\n```\n@Test\npublic void test7() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"555\");\n\n    //when(mock.t5(any() , \"6666\")).thenReturn(\"666\"); //no\n    when(mock.t5(any() , anyString())).thenReturn(\"666\");  //yes\n\n    System.out.println(mock.t5(mockParam , \"ddd\"));\n}\n```\n\n- 自定义参数匹配器，先实现参数匹配器的接口，根据需要在matches里返回true or false  \n\n```\n//定义参数匹配器\nclass MockParamArgMatcher implements ArgumentMatcher<MockParam> {\n\n    @Override\n    public boolean matches(MockParam mockParam) {\n\n        if(mockParam.name.equals(\"666\")) {\n            return true;\n        }\n\n        return false;\n    }\n}\n//使用匹配器\n@Test\npublic void test9() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"666\");\n\n    when(mock.t4(argThat(new MockParamArgMatcher()))).thenReturn(\"666666666\");\n\n    System.out.println(mock.t4(mockParam));\n\n}\n\n```\n\n- 附加参数匹配器(参数验证)   \n\n```\n@Test\npublic void test8() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"555\");\n\n    //在此处可以做入参的逻辑校验\n    //when(mock.t5(any() , eq(\"6666\"))).thenReturn(\"666\");  //yes\n    \n    when(mock.t5(any() , not( and( eq(\"6666\"),eq(\"444\"))) ) ).thenReturn(\"666\");  //yes\n\n    System.out.println(mock.t5(mockParam , \"6667\"));\n}\n```\n\n- 官网推荐的参数验证方式（很好用，使用这个差不多就可以取代断点调试了）\n\n```\n@Test\npublic void test10() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"666\");\n\n    MockParam mockParam1 = new MockParam(\"777\");\n\n    when(mock.t4(any())).thenReturn(\"666666666\");\n\n    System.out.println(mock.t4(mockParam1));\n\n    //参数捕捉器，可以捕捉该类型的入參\n    ArgumentCaptor<MockParam> captor = ArgumentCaptor.forClass(MockParam.class);\n\n    //这条语句一定要执行\n    verify(mock).t4(captor.capture());\n\n    System.out.println(captor.getAllValues().size());\n\n    assertEquals(\"666\" , captor.getValue().name);\n}\n```\n\n#### 其他常规套路\n- 验证调用方法的次数  \n\n```\n@Test\npublic void test11() {\n\n    TestMock mock = mock(TestMock.class);\n\n    mock.t1(\"1\");\n    mock.t1(\"2\");\n    mock.t1(\"3\");\n    mock.t1(\"4\");\n    mock.t1(\"5\");\n    mock.t1(\"6\");\n    mock.t1(\"7\");\n    mock.t1(\"8\");\n\n    verify(mock,times(8)).t1(anyString());\n    verify(mock,atLeast(2)).t1(anyString());\n    verify(mock,atMost(9)).t1(anyString());\n\n}\n```\n\n- 验证方法执行的顺序  \n\n```\n@Test\npublic void test14() {\n\n    TestMock mock = mock(TestMock.class);\n\n    mock.t1(\"\");\n    mock.t2(\"\");\n\n    InOrder inOrder = Mockito.inOrder(mock);\n\n    inOrder.verify(mock).t1(\"\");\n    inOrder.verify(mock).t2(\"\");\n\n}\n```\n\n- doReturn  \n\n```\n @Test\npublic void test16() {\n\n    List list = new LinkedList();\n    List spy = spy(list);\n    //spy 模式会执行代码，但目前list为空\n    //when(spy.get(0)).thenReturn(\"foo\");   //IndexOutOfBoundsException\n    //相当于mock\n    doReturn(\"foo\").when(spy).get(0);\n}\n\n```\n\n---\n\n    \n","source":"_posts/Mockito单元测试常见套路.md","raw":"---\ntitle: Mockito单元测试\ntags: 测试\ndate: 2017-10-07 13:14:07\ncomments: true\n---\n\n## Mokcito单元测试 \n> reference : [mockito doc](http://static.javadoc.io/org.mockito/mockito-core/2.10.0/org/mockito/Mockito.html)\n\n### 单元测试why？  \n- 发现问题的成本最低\n- 调教你的编程习惯\n- 保证代码质量\n### 优点\n- 语法简洁，使用简单，易上手\n- 比较有测试的思维（无法随意Mock）\n### 限制\n- 不能mock静态方法\n- 不能mock构造方法\n- 不能mock equals()，hashCode()\n- 不能mock final类 ， final方法\n- 不能mock私有方法，可以把私有，变成protected\n，若你需要mock私有，可能是你的程序还不够OO (Object Oriented)\n### 常规用法\n#### 大体蓝图  \n当你需要桩（取代某个依赖）的时候，你可以用两种方式来模拟桩，spy & mock\n- spy\n```\nMockedObject object = new MockedObject();  \nMockedObject spiedObject = Mockito.spy(object);\n```\n- mock  \n```\nMockedObject mockedObject = Mockito.mock(MockedObject.class);\n```\n- 两者的区别：    \n\n  当你使用spy来获取到一个桩的时候，你在执行某个方法的时候，spy的对象都会==真正的去执行方法内的代码==。  \n  \n  而当桩是通过mock获取到的话，mock的对象的所有属性都为空，所有方法的返回值都是返回类型的默认值（如对象类型的默认值是null），==方法里的代码不会执行==。 \n  \n  其实这点区别是可以从代码层面上看出来的，spy的时候先拿到了一个对象，然后对对象进行spy，而mock的时候使用的则是字节码。  \n- 两者之间的效果也可以互相转化  \n    spy类型的可以通过 ``` doReturn() ``` ，使得代码不被执行，mock类型可以通过 ``` doRealCallMethod() ``` ,使得代码被执行，所以spy和mock的界限其实并不清晰\n- 代码示例  \n  被mock和spy的类 \n\n```\nclass TestMock{\n\n    public void t1 (String ss) {\n        System.out.println(\"hh\"+ss);\n    }\n\n    public String t2 (String ss) {\n        return \"hh\"+ss;\n    }\n\n    public Boolean t3() {\n        return true;\n    }\n\n    public String t4(MockParam mockParam) {\n\n        return mockParam.name;\n    }\n\n    public String t5(MockParam mockParam , String s) {\n        return s;\n    }\n}\n```\n\n  参数类（在上面的类中的某些方法的参数）   \n\n```\nclass MockParam{\n\n    String name;\n\n    int age;\n\n    public MockParam(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        obj = (MockParam)obj;\n        if(this == obj || this.name.equals(((MockParam) obj).name)) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n  mock样例  \n  所有方法的返回都是方法的默认类型，方法内的代码不会被执行\n\n```\npublic void test2() {\n\n    TestMock mock = mock(TestMock.class);\n\n    mock.t1(\"a\");\n\n    System.out.println(mock.t2(\"b\"));\n\n    System.out.println(mock.t3());\n\n    when(mock.t2(\"c\")).thenReturn(\"666\");\n\n    when(mock.t2(\"c\")).thenReturn(\"777\");\n\n    System.out.println(mock.t2(\"c\"));\n}\n\n```\n  \n  spy样例  \n  所有方法的代码都会被执行，并正常返回  \n\n```\npublic void test3() {\n\n    TestMock mock1 = new TestMock();\n\n    TestMock spyTest = spy(mock1);\n\n    spyTest.t1(\"c\");\n\n    System.out.println(spyTest.t2(\"d\"));\n\n    System.out.println(spyTest.t3());\n\n}\n```\n  \n#### 参数匹配 \n- 通常情况下，参数匹配使用的equals方法  \n\n```\n @Test\npublic void test4() {\n\n    TestMock mock = mock(TestMock.class);\n\n    when(mock.t2(\"c\")).thenReturn(\"777\");\n\n    System.out.println(mock.t2(\"d\"));//d,c equals = false\n}\n\n@Test\npublic void test5() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"555\");\n\n    when(mock.t4(mockParam)).thenReturn(\"555\");\n\n    System.out.println(mock.t4(mockParam));//equals true\n\n    System.out.println(mock.t4(new MockParam(\"555\")));//equals false 可以重写equals方法，使之为ture\n\n}\n```\n\n- 内置参数匹配(常用)  \n\n```\n@Test\npublic void test6() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"555\");\n\n    when(mock.t4(any())).thenReturn(\"555\");\n\n    System.out.println(mock.t4(mockParam));//true\n\n    System.out.println(mock.t4(new MockParam(\"555\")));//true\n\n    when(mock.t2(anyString())).thenReturn(\"dddd\");\n\n    System.out.println(mock.t2(\"aaa\"));//return dddd\n\n    System.out.println(mock.t2(\"bbb\"));//return dddd\n}\n```\n\n- 注意\n⚠ :如果有一个参数使用了参数匹配器，那所有参数都得使用参数匹配器\n\n```\n@Test\npublic void test7() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"555\");\n\n    //when(mock.t5(any() , \"6666\")).thenReturn(\"666\"); //no\n    when(mock.t5(any() , anyString())).thenReturn(\"666\");  //yes\n\n    System.out.println(mock.t5(mockParam , \"ddd\"));\n}\n```\n\n- 自定义参数匹配器，先实现参数匹配器的接口，根据需要在matches里返回true or false  \n\n```\n//定义参数匹配器\nclass MockParamArgMatcher implements ArgumentMatcher<MockParam> {\n\n    @Override\n    public boolean matches(MockParam mockParam) {\n\n        if(mockParam.name.equals(\"666\")) {\n            return true;\n        }\n\n        return false;\n    }\n}\n//使用匹配器\n@Test\npublic void test9() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"666\");\n\n    when(mock.t4(argThat(new MockParamArgMatcher()))).thenReturn(\"666666666\");\n\n    System.out.println(mock.t4(mockParam));\n\n}\n\n```\n\n- 附加参数匹配器(参数验证)   \n\n```\n@Test\npublic void test8() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"555\");\n\n    //在此处可以做入参的逻辑校验\n    //when(mock.t5(any() , eq(\"6666\"))).thenReturn(\"666\");  //yes\n    \n    when(mock.t5(any() , not( and( eq(\"6666\"),eq(\"444\"))) ) ).thenReturn(\"666\");  //yes\n\n    System.out.println(mock.t5(mockParam , \"6667\"));\n}\n```\n\n- 官网推荐的参数验证方式（很好用，使用这个差不多就可以取代断点调试了）\n\n```\n@Test\npublic void test10() {\n\n    TestMock mock = mock(TestMock.class);\n\n    MockParam mockParam = new MockParam(\"666\");\n\n    MockParam mockParam1 = new MockParam(\"777\");\n\n    when(mock.t4(any())).thenReturn(\"666666666\");\n\n    System.out.println(mock.t4(mockParam1));\n\n    //参数捕捉器，可以捕捉该类型的入參\n    ArgumentCaptor<MockParam> captor = ArgumentCaptor.forClass(MockParam.class);\n\n    //这条语句一定要执行\n    verify(mock).t4(captor.capture());\n\n    System.out.println(captor.getAllValues().size());\n\n    assertEquals(\"666\" , captor.getValue().name);\n}\n```\n\n#### 其他常规套路\n- 验证调用方法的次数  \n\n```\n@Test\npublic void test11() {\n\n    TestMock mock = mock(TestMock.class);\n\n    mock.t1(\"1\");\n    mock.t1(\"2\");\n    mock.t1(\"3\");\n    mock.t1(\"4\");\n    mock.t1(\"5\");\n    mock.t1(\"6\");\n    mock.t1(\"7\");\n    mock.t1(\"8\");\n\n    verify(mock,times(8)).t1(anyString());\n    verify(mock,atLeast(2)).t1(anyString());\n    verify(mock,atMost(9)).t1(anyString());\n\n}\n```\n\n- 验证方法执行的顺序  \n\n```\n@Test\npublic void test14() {\n\n    TestMock mock = mock(TestMock.class);\n\n    mock.t1(\"\");\n    mock.t2(\"\");\n\n    InOrder inOrder = Mockito.inOrder(mock);\n\n    inOrder.verify(mock).t1(\"\");\n    inOrder.verify(mock).t2(\"\");\n\n}\n```\n\n- doReturn  \n\n```\n @Test\npublic void test16() {\n\n    List list = new LinkedList();\n    List spy = spy(list);\n    //spy 模式会执行代码，但目前list为空\n    //when(spy.get(0)).thenReturn(\"foo\");   //IndexOutOfBoundsException\n    //相当于mock\n    doReturn(\"foo\").when(spy).get(0);\n}\n\n```\n\n---\n\n    \n","slug":"Mockito单元测试常见套路","published":1,"updated":"2020-03-18T04:17:56.310Z","layout":"post","photos":[],"link":"","_id":"ck7wtmmi80001l54kbgpdjzl5","content":"<h2 id=\"Mokcito单元测试\"><a href=\"#Mokcito单元测试\" class=\"headerlink\" title=\"Mokcito单元测试\"></a>Mokcito单元测试</h2><blockquote>\n<p>reference : <a href=\"http://static.javadoc.io/org.mockito/mockito-core/2.10.0/org/mockito/Mockito.html\" target=\"_blank\" rel=\"external\">mockito doc</a></p>\n</blockquote>\n<h3 id=\"单元测试why？\"><a href=\"#单元测试why？\" class=\"headerlink\" title=\"单元测试why？\"></a>单元测试why？</h3><ul>\n<li>发现问题的成本最低</li>\n<li>调教你的编程习惯</li>\n<li>保证代码质量<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3></li>\n<li>语法简洁，使用简单，易上手</li>\n<li>比较有测试的思维（无法随意Mock）<h3 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h3></li>\n<li>不能mock静态方法</li>\n<li>不能mock构造方法</li>\n<li>不能mock equals()，hashCode()</li>\n<li>不能mock final类 ， final方法</li>\n<li>不能mock私有方法，可以把私有，变成protected<br>，若你需要mock私有，可能是你的程序还不够OO (Object Oriented)<h3 id=\"常规用法\"><a href=\"#常规用法\" class=\"headerlink\" title=\"常规用法\"></a>常规用法</h3><h4 id=\"大体蓝图\"><a href=\"#大体蓝图\" class=\"headerlink\" title=\"大体蓝图\"></a>大体蓝图</h4>当你需要桩（取代某个依赖）的时候，你可以用两种方式来模拟桩，spy &amp; mock</li>\n<li><p>spy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">MockedObject object = new MockedObject();  </div><div class=\"line\">MockedObject spiedObject = Mockito.spy(object);</div></pre></td></tr></table></figure>\n</li>\n<li><p>mock  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MockedObject mockedObject = Mockito.mock(MockedObject.class);</div></pre></td></tr></table></figure>\n</li>\n<li><p>两者的区别：    </p>\n<p>当你使用spy来获取到一个桩的时候，你在执行某个方法的时候，spy的对象都会==真正的去执行方法内的代码==。  </p>\n<p>而当桩是通过mock获取到的话，mock的对象的所有属性都为空，所有方法的返回值都是返回类型的默认值（如对象类型的默认值是null），==方法里的代码不会执行==。 </p>\n<p>其实这点区别是可以从代码层面上看出来的，spy的时候先拿到了一个对象，然后对对象进行spy，而mock的时候使用的则是字节码。  </p>\n</li>\n<li>两者之间的效果也可以互相转化<br>  spy类型的可以通过 <figure class=\"highlight plain\"><figcaption><span>``` ，使得代码不被执行，mock类型可以通过 ``` doRealCallMethod() ``` ,使得代码被执行，所以spy和mock的界限其实并不清晰</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 代码示例  </div><div class=\"line\">  被mock和spy的类</div></pre></td></tr></table></figure></li>\n</ul>\n<p>class TestMock{</p>\n<pre><code>public void t1 (String ss) {\n    System.out.println(&quot;hh&quot;+ss);\n}\n\npublic String t2 (String ss) {\n    return &quot;hh&quot;+ss;\n}\n\npublic Boolean t3() {\n    return true;\n}\n\npublic String t4(MockParam mockParam) {\n\n    return mockParam.name;\n}\n\npublic String t5(MockParam mockParam , String s) {\n    return s;\n}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">参数类（在上面的类中的某些方法的参数）</div></pre></td></tr></table></figure></p>\n<p>class MockParam{</p>\n<pre><code>String name;\n\nint age;\n\npublic MockParam(String name) {\n    this.name = name;\n}\n\n@Override\npublic boolean equals(Object obj) {\n    obj = (MockParam)obj;\n    if(this == obj || this.name.equals(((MockParam) obj).name)) {\n        return true;\n    }\n    return false;\n}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">mock样例  </div><div class=\"line\">所有方法的返回都是方法的默认类型，方法内的代码不会被执行</div></pre></td></tr></table></figure></p>\n<p>public void test2() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nmock.t1(&quot;a&quot;);\n\nSystem.out.println(mock.t2(&quot;b&quot;));\n\nSystem.out.println(mock.t3());\n\nwhen(mock.t2(&quot;c&quot;)).thenReturn(&quot;666&quot;);\n\nwhen(mock.t2(&quot;c&quot;)).thenReturn(&quot;777&quot;);\n\nSystem.out.println(mock.t2(&quot;c&quot;));\n</code></pre><p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">spy样例  </div><div class=\"line\">所有方法的代码都会被执行，并正常返回</div></pre></td></tr></table></figure>\n<p>public void test3() {</p>\n<pre><code>TestMock mock1 = new TestMock();\n\nTestMock spyTest = spy(mock1);\n\nspyTest.t1(&quot;c&quot;);\n\nSystem.out.println(spyTest.t2(&quot;d&quot;));\n\nSystem.out.println(spyTest.t3());\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  </div><div class=\"line\">#### 参数匹配 </div><div class=\"line\">- 通常情况下，参数匹配使用的equals方法</div></pre></td></tr></table></figure></p>\n<p> @Test<br>public void test4() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nwhen(mock.t2(&quot;c&quot;)).thenReturn(&quot;777&quot;);\n\nSystem.out.println(mock.t2(&quot;d&quot;));//d,c equals = false\n</code></pre><p>}</p>\n<p>@Test<br>public void test5() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;555&quot;);\n\nwhen(mock.t4(mockParam)).thenReturn(&quot;555&quot;);\n\nSystem.out.println(mock.t4(mockParam));//equals true\n\nSystem.out.println(mock.t4(new MockParam(&quot;555&quot;)));//equals false 可以重写equals方法，使之为ture\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 内置参数匹配(常用)</div></pre></td></tr></table></figure></p>\n<p>@Test<br>public void test6() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;555&quot;);\n\nwhen(mock.t4(any())).thenReturn(&quot;555&quot;);\n\nSystem.out.println(mock.t4(mockParam));//true\n\nSystem.out.println(mock.t4(new MockParam(&quot;555&quot;)));//true\n\nwhen(mock.t2(anyString())).thenReturn(&quot;dddd&quot;);\n\nSystem.out.println(mock.t2(&quot;aaa&quot;));//return dddd\n\nSystem.out.println(mock.t2(&quot;bbb&quot;));//return dddd\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 注意</div><div class=\"line\">⚠ :如果有一个参数使用了参数匹配器，那所有参数都得使用参数匹配器</div></pre></td></tr></table></figure></p>\n<p>@Test<br>public void test7() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;555&quot;);\n\n//when(mock.t5(any() , &quot;6666&quot;)).thenReturn(&quot;666&quot;); //no\nwhen(mock.t5(any() , anyString())).thenReturn(&quot;666&quot;);  //yes\n\nSystem.out.println(mock.t5(mockParam , &quot;ddd&quot;));\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 自定义参数匹配器，先实现参数匹配器的接口，根据需要在matches里返回true or false</div></pre></td></tr></table></figure></p>\n<p>//定义参数匹配器<br>class MockParamArgMatcher implements ArgumentMatcher<mockparam> {</mockparam></p>\n<pre><code>@Override\npublic boolean matches(MockParam mockParam) {\n\n    if(mockParam.name.equals(&quot;666&quot;)) {\n        return true;\n    }\n\n    return false;\n}\n</code></pre><p>}<br>//使用匹配器<br>@Test<br>public void test9() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;666&quot;);\n\nwhen(mock.t4(argThat(new MockParamArgMatcher()))).thenReturn(&quot;666666666&quot;);\n\nSystem.out.println(mock.t4(mockParam));\n</code></pre><p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 附加参数匹配器(参数验证)</div></pre></td></tr></table></figure>\n<p>@Test<br>public void test8() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;555&quot;);\n\n//在此处可以做入参的逻辑校验\n//when(mock.t5(any() , eq(&quot;6666&quot;))).thenReturn(&quot;666&quot;);  //yes\n\nwhen(mock.t5(any() , not( and( eq(&quot;6666&quot;),eq(&quot;444&quot;))) ) ).thenReturn(&quot;666&quot;);  //yes\n\nSystem.out.println(mock.t5(mockParam , &quot;6667&quot;));\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 官网推荐的参数验证方式（很好用，使用这个差不多就可以取代断点调试了）</div></pre></td></tr></table></figure></p>\n<p>@Test<br>public void test10() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;666&quot;);\n\nMockParam mockParam1 = new MockParam(&quot;777&quot;);\n\nwhen(mock.t4(any())).thenReturn(&quot;666666666&quot;);\n\nSystem.out.println(mock.t4(mockParam1));\n\n//参数捕捉器，可以捕捉该类型的入參\nArgumentCaptor&lt;MockParam&gt; captor = ArgumentCaptor.forClass(MockParam.class);\n\n//这条语句一定要执行\nverify(mock).t4(captor.capture());\n\nSystem.out.println(captor.getAllValues().size());\n\nassertEquals(&quot;666&quot; , captor.getValue().name);\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 其他常规套路</div><div class=\"line\">- 验证调用方法的次数</div></pre></td></tr></table></figure></p>\n<p>@Test<br>public void test11() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nmock.t1(&quot;1&quot;);\nmock.t1(&quot;2&quot;);\nmock.t1(&quot;3&quot;);\nmock.t1(&quot;4&quot;);\nmock.t1(&quot;5&quot;);\nmock.t1(&quot;6&quot;);\nmock.t1(&quot;7&quot;);\nmock.t1(&quot;8&quot;);\n\nverify(mock,times(8)).t1(anyString());\nverify(mock,atLeast(2)).t1(anyString());\nverify(mock,atMost(9)).t1(anyString());\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 验证方法执行的顺序</div></pre></td></tr></table></figure></p>\n<p>@Test<br>public void test14() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nmock.t1(&quot;&quot;);\nmock.t2(&quot;&quot;);\n\nInOrder inOrder = Mockito.inOrder(mock);\n\ninOrder.verify(mock).t1(&quot;&quot;);\ninOrder.verify(mock).t2(&quot;&quot;);\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- doReturn</div></pre></td></tr></table></figure></p>\n<p> @Test<br>public void test16() {</p>\n<pre><code>List list = new LinkedList();\nList spy = spy(list);\n//spy 模式会执行代码，但目前list为空\n//when(spy.get(0)).thenReturn(&quot;foo&quot;);   //IndexOutOfBoundsException\n//相当于mock\ndoReturn(&quot;foo&quot;).when(spy).get(0);\n</code></pre><p>}</p>\n<p>```</p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Mokcito单元测试\"><a href=\"#Mokcito单元测试\" class=\"headerlink\" title=\"Mokcito单元测试\"></a>Mokcito单元测试</h2><blockquote>\n<p>reference : <a href=\"http://static.javadoc.io/org.mockito/mockito-core/2.10.0/org/mockito/Mockito.html\" target=\"_blank\" rel=\"external\">mockito doc</a></p>\n</blockquote>\n<h3 id=\"单元测试why？\"><a href=\"#单元测试why？\" class=\"headerlink\" title=\"单元测试why？\"></a>单元测试why？</h3><ul>\n<li>发现问题的成本最低</li>\n<li>调教你的编程习惯</li>\n<li>保证代码质量<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3></li>\n<li>语法简洁，使用简单，易上手</li>\n<li>比较有测试的思维（无法随意Mock）<h3 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h3></li>\n<li>不能mock静态方法</li>\n<li>不能mock构造方法</li>\n<li>不能mock equals()，hashCode()</li>\n<li>不能mock final类 ， final方法</li>\n<li>不能mock私有方法，可以把私有，变成protected<br>，若你需要mock私有，可能是你的程序还不够OO (Object Oriented)<h3 id=\"常规用法\"><a href=\"#常规用法\" class=\"headerlink\" title=\"常规用法\"></a>常规用法</h3><h4 id=\"大体蓝图\"><a href=\"#大体蓝图\" class=\"headerlink\" title=\"大体蓝图\"></a>大体蓝图</h4>当你需要桩（取代某个依赖）的时候，你可以用两种方式来模拟桩，spy &amp; mock</li>\n<li><p>spy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">MockedObject object = new MockedObject();  </div><div class=\"line\">MockedObject spiedObject = Mockito.spy(object);</div></pre></td></tr></table></figure>\n</li>\n<li><p>mock  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">MockedObject mockedObject = Mockito.mock(MockedObject.class);</div></pre></td></tr></table></figure>\n</li>\n<li><p>两者的区别：    </p>\n<p>当你使用spy来获取到一个桩的时候，你在执行某个方法的时候，spy的对象都会==真正的去执行方法内的代码==。  </p>\n<p>而当桩是通过mock获取到的话，mock的对象的所有属性都为空，所有方法的返回值都是返回类型的默认值（如对象类型的默认值是null），==方法里的代码不会执行==。 </p>\n<p>其实这点区别是可以从代码层面上看出来的，spy的时候先拿到了一个对象，然后对对象进行spy，而mock的时候使用的则是字节码。  </p>\n</li>\n<li>两者之间的效果也可以互相转化<br>  spy类型的可以通过 <figure class=\"highlight plain\"><figcaption><span>``` ，使得代码不被执行，mock类型可以通过 ``` doRealCallMethod() ``` ,使得代码被执行，所以spy和mock的界限其实并不清晰</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 代码示例  </div><div class=\"line\">  被mock和spy的类</div></pre></td></tr></table></figure></li>\n</ul>\n<p>class TestMock{</p>\n<pre><code>public void t1 (String ss) {\n    System.out.println(&quot;hh&quot;+ss);\n}\n\npublic String t2 (String ss) {\n    return &quot;hh&quot;+ss;\n}\n\npublic Boolean t3() {\n    return true;\n}\n\npublic String t4(MockParam mockParam) {\n\n    return mockParam.name;\n}\n\npublic String t5(MockParam mockParam , String s) {\n    return s;\n}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">参数类（在上面的类中的某些方法的参数）</div></pre></td></tr></table></figure></p>\n<p>class MockParam{</p>\n<pre><code>String name;\n\nint age;\n\npublic MockParam(String name) {\n    this.name = name;\n}\n\n@Override\npublic boolean equals(Object obj) {\n    obj = (MockParam)obj;\n    if(this == obj || this.name.equals(((MockParam) obj).name)) {\n        return true;\n    }\n    return false;\n}\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">mock样例  </div><div class=\"line\">所有方法的返回都是方法的默认类型，方法内的代码不会被执行</div></pre></td></tr></table></figure></p>\n<p>public void test2() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nmock.t1(&quot;a&quot;);\n\nSystem.out.println(mock.t2(&quot;b&quot;));\n\nSystem.out.println(mock.t3());\n\nwhen(mock.t2(&quot;c&quot;)).thenReturn(&quot;666&quot;);\n\nwhen(mock.t2(&quot;c&quot;)).thenReturn(&quot;777&quot;);\n\nSystem.out.println(mock.t2(&quot;c&quot;));\n</code></pre><p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">spy样例  </div><div class=\"line\">所有方法的代码都会被执行，并正常返回</div></pre></td></tr></table></figure>\n<p>public void test3() {</p>\n<pre><code>TestMock mock1 = new TestMock();\n\nTestMock spyTest = spy(mock1);\n\nspyTest.t1(&quot;c&quot;);\n\nSystem.out.println(spyTest.t2(&quot;d&quot;));\n\nSystem.out.println(spyTest.t3());\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  </div><div class=\"line\">#### 参数匹配 </div><div class=\"line\">- 通常情况下，参数匹配使用的equals方法</div></pre></td></tr></table></figure></p>\n<p> @Test<br>public void test4() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nwhen(mock.t2(&quot;c&quot;)).thenReturn(&quot;777&quot;);\n\nSystem.out.println(mock.t2(&quot;d&quot;));//d,c equals = false\n</code></pre><p>}</p>\n<p>@Test<br>public void test5() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;555&quot;);\n\nwhen(mock.t4(mockParam)).thenReturn(&quot;555&quot;);\n\nSystem.out.println(mock.t4(mockParam));//equals true\n\nSystem.out.println(mock.t4(new MockParam(&quot;555&quot;)));//equals false 可以重写equals方法，使之为ture\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 内置参数匹配(常用)</div></pre></td></tr></table></figure></p>\n<p>@Test<br>public void test6() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;555&quot;);\n\nwhen(mock.t4(any())).thenReturn(&quot;555&quot;);\n\nSystem.out.println(mock.t4(mockParam));//true\n\nSystem.out.println(mock.t4(new MockParam(&quot;555&quot;)));//true\n\nwhen(mock.t2(anyString())).thenReturn(&quot;dddd&quot;);\n\nSystem.out.println(mock.t2(&quot;aaa&quot;));//return dddd\n\nSystem.out.println(mock.t2(&quot;bbb&quot;));//return dddd\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 注意</div><div class=\"line\">⚠ :如果有一个参数使用了参数匹配器，那所有参数都得使用参数匹配器</div></pre></td></tr></table></figure></p>\n<p>@Test<br>public void test7() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;555&quot;);\n\n//when(mock.t5(any() , &quot;6666&quot;)).thenReturn(&quot;666&quot;); //no\nwhen(mock.t5(any() , anyString())).thenReturn(&quot;666&quot;);  //yes\n\nSystem.out.println(mock.t5(mockParam , &quot;ddd&quot;));\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 自定义参数匹配器，先实现参数匹配器的接口，根据需要在matches里返回true or false</div></pre></td></tr></table></figure></p>\n<p>//定义参数匹配器<br>class MockParamArgMatcher implements ArgumentMatcher<mockparam> {</mockparam></p>\n<pre><code>@Override\npublic boolean matches(MockParam mockParam) {\n\n    if(mockParam.name.equals(&quot;666&quot;)) {\n        return true;\n    }\n\n    return false;\n}\n</code></pre><p>}<br>//使用匹配器<br>@Test<br>public void test9() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;666&quot;);\n\nwhen(mock.t4(argThat(new MockParamArgMatcher()))).thenReturn(&quot;666666666&quot;);\n\nSystem.out.println(mock.t4(mockParam));\n</code></pre><p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 附加参数匹配器(参数验证)</div></pre></td></tr></table></figure>\n<p>@Test<br>public void test8() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;555&quot;);\n\n//在此处可以做入参的逻辑校验\n//when(mock.t5(any() , eq(&quot;6666&quot;))).thenReturn(&quot;666&quot;);  //yes\n\nwhen(mock.t5(any() , not( and( eq(&quot;6666&quot;),eq(&quot;444&quot;))) ) ).thenReturn(&quot;666&quot;);  //yes\n\nSystem.out.println(mock.t5(mockParam , &quot;6667&quot;));\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 官网推荐的参数验证方式（很好用，使用这个差不多就可以取代断点调试了）</div></pre></td></tr></table></figure></p>\n<p>@Test<br>public void test10() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nMockParam mockParam = new MockParam(&quot;666&quot;);\n\nMockParam mockParam1 = new MockParam(&quot;777&quot;);\n\nwhen(mock.t4(any())).thenReturn(&quot;666666666&quot;);\n\nSystem.out.println(mock.t4(mockParam1));\n\n//参数捕捉器，可以捕捉该类型的入參\nArgumentCaptor&lt;MockParam&gt; captor = ArgumentCaptor.forClass(MockParam.class);\n\n//这条语句一定要执行\nverify(mock).t4(captor.capture());\n\nSystem.out.println(captor.getAllValues().size());\n\nassertEquals(&quot;666&quot; , captor.getValue().name);\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 其他常规套路</div><div class=\"line\">- 验证调用方法的次数</div></pre></td></tr></table></figure></p>\n<p>@Test<br>public void test11() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nmock.t1(&quot;1&quot;);\nmock.t1(&quot;2&quot;);\nmock.t1(&quot;3&quot;);\nmock.t1(&quot;4&quot;);\nmock.t1(&quot;5&quot;);\nmock.t1(&quot;6&quot;);\nmock.t1(&quot;7&quot;);\nmock.t1(&quot;8&quot;);\n\nverify(mock,times(8)).t1(anyString());\nverify(mock,atLeast(2)).t1(anyString());\nverify(mock,atMost(9)).t1(anyString());\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 验证方法执行的顺序</div></pre></td></tr></table></figure></p>\n<p>@Test<br>public void test14() {</p>\n<pre><code>TestMock mock = mock(TestMock.class);\n\nmock.t1(&quot;&quot;);\nmock.t2(&quot;&quot;);\n\nInOrder inOrder = Mockito.inOrder(mock);\n\ninOrder.verify(mock).t1(&quot;&quot;);\ninOrder.verify(mock).t2(&quot;&quot;);\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- doReturn</div></pre></td></tr></table></figure></p>\n<p> @Test<br>public void test16() {</p>\n<pre><code>List list = new LinkedList();\nList spy = spy(list);\n//spy 模式会执行代码，但目前list为空\n//when(spy.get(0)).thenReturn(&quot;foo&quot;);   //IndexOutOfBoundsException\n//相当于mock\ndoReturn(&quot;foo&quot;).when(spy).get(0);\n</code></pre><p>}</p>\n<p>```</p>\n<hr>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck7wtmmi20000l54k3xmxp61l","tag_id":"ck7wtmmib0002l54kdmc0bc0p","_id":"ck7wtmmie0004l54koxhbobra"},{"post_id":"ck7wtmmi80001l54kbgpdjzl5","tag_id":"ck7wtmmie0003l54kx5gngh8e","_id":"ck7wtmmij0005l54k0y4wf2gp"}],"Tag":[{"name":"闲言碎语","_id":"ck7wtmmib0002l54kdmc0bc0p"},{"name":"测试","_id":"ck7wtmmie0003l54kx5gngh8e"}]}}